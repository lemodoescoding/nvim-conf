{
  "BST C++": {
    "prefix": "bst",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "struct BSTNode {",
      "    BSTNode *left, *right;",
      "    int key;",
      "};",
      "",
      "struct BST {",
      "    // Member",
      "    BSTNode *_root;",
      "    unsigned int _size;",
      "",
      "    // Function",
      "    void init() {",
      "        _root = NULL;",
      "        _size = 0u;",
      "    }",
      "",
      "    bool isEmpty() {",
      "        return _root == NULL;",
      "    }",
      "",
      "    bool find(int value) {",
      "        BSTNode *temp = __search(_root, value);",
      "        if (!temp)",
      "            return false;",
      "        ",
      "        if (temp->key == value)",
      "            return true;",
      "        else",
      "            return false;",
      "    }",
      "",
      "    void insert(int value) {",
      "        if (!find(value)) {",
      "            _root = __insert(_root, value);",
      "            _size++;",
      "        }",
      "    }",
      "",
      "    void remove(int value) {",
      "        if (find(value)) {",
      "            _root = __remove(_root, value);",
      "            _size++;",
      "        }",
      "    }",
      "",
      "    void traverseInorder() {",
      "        __inorder(_root);",
      "    }",
      "",
      "    void traversePreorder() {",
      "        __preorder(_root);",
      "    }",
      "",
      "    void traversePostorder() {",
      "        __postorder(_root);",
      "    }",
      "",
      "private:",
      "    // Utility Function",
      "    BSTNode* __createNode(int value) {",
      "        BSTNode *newNode = (BSTNode*) malloc(sizeof(BSTNode));",
      "        newNode->key = value;",
      "        newNode->left = newNode->right = NULL;",
      "        return newNode;",
      "    }",
      "    ",
      "    BSTNode* __search(BSTNode *root, int value) {",
      "        while (root != NULL) {",
      "            if (value < root->key)",
      "                root = root->left;",
      "            else if (value > root->key)",
      "                root = root->right;",
      "            else",
      "                return root;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    BSTNode* __insert(BSTNode *root, int value) {",
      "        if (root == NULL)",
      "            return __createNode(value);",
      "        ",
      "        if (value < root->key)",
      "            root->left = __insert(root->left, value);",
      "        else if (value > root->key)",
      "            root->right = __insert(root->right, value);",
      "        ",
      "        return root;",
      "    }",
      "",
      "    BSTNode* __findMinNode(BSTNode *node) {",
      "        BSTNode *currNode = node;",
      "        while (currNode && currNode->left != NULL)",
      "            currNode = currNode->left;",
      "        ",
      "        return currNode;",
      "    }",
      "",
      "    BSTNode* __remove(BSTNode *root, int value) {",
      "        if (root == NULL) return NULL;",
      "",
      "        if (value > root->key) ",
      "            root->right = __remove(root->right, value);",
      "        else if (value < root->key) ",
      "            root->left = __remove(root->left, value);",
      "        else {",
      "",
      "            if (root->left == NULL) {",
      "                BSTNode *rightChild = root->right;",
      "                free(root);",
      "                return rightChild;",
      "            }",
      "            else if (root->right == NULL) {",
      "                BSTNode *leftChild = root->left;",
      "                free(root);",
      "                return leftChild;",
      "            }",
      "",
      "            BSTNode *temp = __findMinNode(root->right);",
      "            root->key     = temp->key;",
      "            root->right   = __remove(root->right, temp->key);",
      "        }",
      "        return root;",
      "    }",
      "",
      "    void __inorder(BSTNode *root) {",
      "        if (root) {",
      "            __inorder(root->left);",
      "            printf(\"%d \", root->key);",
      "            __inorder(root->right);",
      "        }",
      "    }",
      "",
      "    void __postorder(BSTNode *root) {",
      "        if (root) {",
      "            __postorder(root->left);",
      "            __postorder(root->right);",
      "            printf(\"%d \", root->key);",
      "        }",
      "    }",
      "",
      "    void __preorder(BSTNode *root) {",
      "        if (root) {",
      "            printf(\"%d \", root->key);",
      "            __preorder(root->left);",
      "            __preorder(root->right);",
      "        }",
      "    }",
      "};"
    ],
    "description": "BST Tree Code C/C++"
  },
  "BST C": {
    "prefix": "bst_c",
    "body": [
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "",
      "typedef struct bstnode_t {",
      "    int key;",
      "    struct bstnode_t \\",
      "        *left, *right;",
      "} BSTNode;",
      "",
      "typedef struct bst_t {",
      "    BSTNode *_root;",
      "    unsigned int _size;",
      "} BST;",
      "",
      "BSTNode* __bst__createNode(int value) {",
      "    BSTNode *newNode = (BSTNode*) malloc(sizeof(BSTNode));",
      "    newNode->key = value;",
      "    newNode->left = newNode->right = NULL;",
      "    return newNode;",
      "}",
      "",
      "BSTNode* __bst__insert(BSTNode *root, int value) {",
      "    if (root == NULL) ",
      "        return __bst__createNode(value);",
      "",
      "    if (value < root->key)",
      "        root->left = __bst__insert(root->left, value);",
      "    else if (value > root->key)",
      "        root->right = __bst__insert(root->right, value);",
      "    ",
      "    return root;",
      "}",
      "",
      "BSTNode* __bst__search(BSTNode *root, int value) {",
      "    while (root != NULL) {",
      "        if (value < root->key)",
      "            root = root->left;",
      "        else if (value > root->key)",
      "            root = root->right;",
      "        else",
      "            return root;",
      "    }",
      "    return root;",
      "}",
      "",
      "BSTNode* __bst__findMinNode(BSTNode *node) {",
      "    BSTNode *currNode = node;",
      "    while (currNode && currNode->left != NULL)",
      "        currNode = currNode->left;",
      "    ",
      "    return currNode;",
      "}",
      "",
      "BSTNode* __bst__remove(BSTNode *root, int value) {",
      "    if (root == NULL) return NULL;",
      "",
      "    if (value > root->key) ",
      "        root->right = __bst__remove(root->right, value);",
      "    else if (value < root->key) ",
      "        root->left = __bst__remove(root->left, value);",
      "    else {",
      "        ",
      "        if (root->left == NULL) {",
      "            BSTNode *rightChild = root->right;",
      "            free(root);",
      "            return rightChild;",
      "        }",
      "        else if (root->right == NULL) {",
      "            BSTNode *leftChild = root->left;",
      "            free(root);",
      "            return leftChild;",
      "        }",
      "",
      "        BSTNode *temp = __bst__findMinNode(root->right);",
      "        root->key     = temp->key;",
      "        root->right   = __bst__remove(root->right, temp->key);",
      "    }",
      "    return root;",
      "}",
      "",
      "void __bst__inorder(BSTNode *root) {",
      "    if (root) {",
      "        __bst__inorder(root->left);",
      "        printf(\"%d \", root->key);",
      "        __bst__inorder(root->right);",
      "    }",
      "}",
      "",
      "void __bst__postorder(BSTNode *root) {",
      "    if (root) {",
      "        __bst__postorder(root->left);",
      "        __bst__postorder(root->right);",
      "        printf(\"%d \", root->key);",
      "    }",
      "}",
      "",
      "void __bst__preorder(BSTNode *root) {",
      "    if (root) {",
      "        printf(\"%d \", root->key);",
      "        __bst__preorder(root->left);",
      "        __bst__preorder(root->right);",
      "    }",
      "}",
      "",
      "void bst_init(BST *bst) {",
      "    bst->_root = NULL;",
      "    bst->_size = 0u;",
      "}",
      "",
      "bool bst_isEmpty(BST *bst) {",
      "    return bst->_root == NULL;",
      "}",
      "",
      "bool bst_find(BST *bst, int value) {",
      "    BSTNode *temp = __bst__search(bst->_root, value);",
      "    if (temp == NULL)",
      "        return false;",
      "    ",
      "    if (temp->key == value)",
      "        return true;",
      "    else",
      "        return false;",
      "}",
      "",
      "void bst_insert(BST *bst, int value) {",
      "    if (!bst_find(bst, value)) {",
      "        bst->_root = __bst__insert(bst->_root, value);",
      "        bst->_size++;",
      "    }",
      "}",
      "",
      "void bst_remove(BST *bst, int value) {",
      "    if (bst_find(bst, value)) {",
      "        bst->_root = __bst__remove(bst->_root, value);",
      "        bst->_size--;",
      "    }",
      "}"
    ],
    "description": "BST C"
  },
  "AVL Tree Init": {
    "prefix": "avl_init",
    "body": [
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "typedef struct Node {",
      "  int _data, _height;",
      "  struct Node *_left, *_right;",
      "} AVLNode;",
      "",
      "typedef struct {",
      "  AVLNode *_root;",
      "  size_t _size;",
      "} AVLTree;"
    ],
    "description": "AVL Tree Init"
  },
  "AVL Tree Utils": {
    "prefix": "avl_utils",
    "body": [
      "int _getHeight(AVLNode *node) { return (node == NULL) ? 0 : node->_height; }",
      "",
      "int _getBalanceFactor(AVLNode *node) {",
      "  if (node == NULL)",
      "    return 0;",
      "",
      "  return _getHeight(node->_left) - _getHeight(node->_right);",
      "}",
      "",
      "int _max(int a, int b) { return (a > b) ? a : b; }"
    ],
    "description": "AVL Tree Utils"
  },
  "AVL Node Create": {
    "prefix": "avl_creat",
    "body": [
      "AVLNode *createNode(int data) {",
      "  AVLNode *temp = (AVLNode *)malloc(sizeof(AVLNode));",
      "",
      "  if (!temp)",
      "    return NULL;",
      "",
      "  temp->_data = data;",
      "  temp->_height = 1;",
      "  temp->_left = temp->_right = NULL;",
      "",
      "  return temp;",
      "}"
    ],
    "description": "AVL Node Create"
  },
  "AVL Rotate": {
    "prefix": "avl_rotat",
    "body": [
      "AVLNode *avlRightRotate(AVLNode *pivotNode) {",
      "  AVLNode *newParent = pivotNode->_left;",
      "  pivotNode->_left = newParent->_right;",
      "  newParent->_right = pivotNode;",
      "",
      "  pivotNode->_height =",
      "      _max(_getHeight(pivotNode->_left), _getHeight(pivotNode->_right)) + 1;",
      "  newParent->_height =",
      "      _max(_getHeight(newParent->_left), _getHeight(newParent->_right)) + 1;",
      "",
      "  return newParent;",
      "}",
      "",
      "AVLNode *avlLeftRotate(AVLNode *pivotNode) {",
      "  AVLNode *newParent = pivotNode->_right;",
      "  pivotNode->_right = newParent->_left;",
      "  newParent->_left = pivotNode;",
      "",
      "  pivotNode->_height =",
      "      _max(_getHeight(pivotNode->_left), _getHeight(pivotNode->_right)) + 1;",
      "  newParent->_height =",
      "      _max(_getHeight(newParent->_left), _getHeight(newParent->_right)) + 1;",
      "",
      "  return newParent;",
      "}",
      "",
      "AVLNode *leftCaseRotate(AVLNode *node) { return avlRightRotate(node); }",
      "AVLNode *rightCaseRotate(AVLNode *node) { return avlLeftRotate(node); }",
      "",
      "AVLNode *leftRightCaseRotate(AVLNode *node) {",
      "  node->_left = avlLeftRotate(node->_left);",
      "  return avlRightRotate(node);",
      "}",
      "",
      "AVLNode *rightLeftCaseRotate(AVLNode *node) {",
      "  node->_right = avlRightRotate(node->_right);",
      "  return avlLeftRotate(node);",
      "}"
    ],
    "description": "AVL Rotate"
  },
  "AVL Find": {
    "prefix": "avl_find",
    "body": [
      "AVLNode *avlSearchNode(AVLNode *root, int data) {",
      "  if (root == NULL)",
      "    return root;",
      "",
      "  if (data < root->_data) {",
      "    return avlSearchNode(root->_left, data);",
      "  } else if (data > root->_data) {",
      "    return avlSearchNode(root->_right, data);",
      "  } else {",
      "    return root;",
      "  }",
      "}",
      "",
      "bool AVLFindNode(AVLTree *avl, int data) {",
      "  AVLNode *temp = avlSearchNode(avl->_root, data);",
      "",
      "  if (temp == NULL || temp->_data != data)",
      "    return false;",
      "  else",
      "    return true;",
      "}"
    ],
    "description": "AVL Find"
  },
  "AVL Insert": {
    "prefix": "avl_insert",
    "body": [
      "AVLNode *avlInsertNode(AVLTree *avl, AVLNode *node, int data) {",
      "  if (node == NULL)",
      "    return createNode(data);",
      "",
      "  if (data < node->_data)",
      "    node->_left = avlInsertNode(avl, node->_left, data);",
      "  else if (data > node->_data)",
      "    node->_right = avlInsertNode(avl, node->_right, data);",
      "",
      "  node->_height = 1 + _max(_getHeight(node->_left), _getHeight(node->_right));",
      "",
      "  int balanceFactor = _getBalanceFactor(node);",
      "  if (balanceFactor > 1 && data < node->_left->_data)",
      "    return leftCaseRotate(node);",
      "  if (balanceFactor > 1 && data > node->_left->_data)",
      "    return leftRightCaseRotate(node);",
      "  if (balanceFactor < -1 && data > node->_right->_data)",
      "    return rightCaseRotate(node);",
      "  if (balanceFactor < -1 && data < node->_right->_data)",
      "    return rightLeftCaseRotate(node);",
      "",
      "  return node;",
      "}",
      "",
      "void InsertToAVL(AVLTree *avl, int data) {",
      "  if (AVLFindNode(avl, data))",
      "    return;",
      "",
      "  avl->_root = avlInsertNode(avl, avl->_root, data);",
      "  avl->_size++;",
      "}"
    ],
    "description": "AVL Insert"
  },
  "AVL Delete": {
    "prefix": "avl_del",
    "body": [
      "AVLNode *_findMinNode(AVLNode *node) {",
      "  AVLNode *currNode = node;",
      "  while (currNode && currNode->_left != NULL)",
      "    currNode = currNode->_left;",
      "  return currNode;",
      "}",
      "",
      "AVLNode *_remove_AVL(AVLNode *node, int value) {",
      "  if (node == NULL)",
      "    return node;",
      "  if (value > node->_data)",
      "    node->_right = _remove_AVL(node->_right, value);",
      "  else if (value < node->_data)",
      "    node->_left = _remove_AVL(node->_left, value);",
      "  else {",
      "    AVLNode *temp;",
      "    if ((node->_left == NULL) || (node->_right == NULL)) {",
      "      temp = NULL;",
      "      if (node->_left == NULL)",
      "        temp = node->_right;",
      "      else if (node->_right == NULL)",
      "        temp = node->_left;",
      "",
      "      if (temp == NULL) {",
      "        temp = node;",
      "        node = NULL;",
      "      } else",
      "        *node = *temp;",
      "",
      "      free(temp);",
      "    } else {",
      "      temp = _findMinNode(node->_right);",
      "      node->_data = temp->_data;",
      "      node->_right = _remove_AVL(node->_right, temp->_data);",
      "    }",
      "  }",
      "  if (node == NULL)",
      "    return node;",
      "",
      "  node->_height = _max(_getHeight(node->_left), _getHeight(node->_right)) + 1;",
      "",
      "  int balanceFactor = _getBalanceFactor(node);",
      "",
      "  if (balanceFactor > 1 && _getBalanceFactor(node->_left) >= 0)",
      "    return leftCaseRotate(node);",
      "",
      "  if (balanceFactor > 1 && _getBalanceFactor(node->_left) < 0)",
      "    return leftRightCaseRotate(node);",
      "",
      "  if (balanceFactor < -1 && _getBalanceFactor(node->_right) <= 0)",
      "    return rightCaseRotate(node);",
      "",
      "  if (balanceFactor < -1 && _getBalanceFactor(node->_right) > 0)",
      "    return rightLeftCaseRotate(node);",
      "",
      "  return node;",
      "}"
    ],
    "description": "AVL Delete"
  },
  "Simple printf": {
    "prefix": "ptf",
    "body": ["printf(\"$1\", $2);"],
    "description": "Simple printf"
  },
  "Simple printf C++": {
    "prefix": "ptf_cpp",
    "body": ["cout << \"$1\" << endl;"],
    "description": "Simple printf C++"
  },
  "Set Int C++": {
    "prefix": "seti",
    "body": ["#include <set>", "", "set<int> ${1:mySet};"],
    "description": "Set Int C++"
  },
  "Set GtInt C++": {
    "prefix": "setgti",
    "body": ["set<int, greater<int>> $1;"],
    "description": "Set GtInt C++"
  },
  "Loop Set C++": {
    "prefix": "stdlp",
    "body": [
      " for (auto i = $1.begin(); i != $1.end(); i++) {",
      "   cout << *i << endl;",
      " }"
    ],
    "description": "Loop Set C++"
  },
  "Std Find C++": {
    "prefix": "stdfd",
    "body": ["auto pointer = $1.find($2);"],
    "description": "Set Find C++"
  },
  "Std Del C++": {
    "prefix": "stddl",
    "body": ["$1.erase($2);"],
    "description": "Set Del C++"
  },
  "Map Creat C++": {
    "prefix": "mapcr",
    "body": ["map<int, int> $1;"],
    "description": "Map Creat C++"
  },
  "Map Insert Manual C++": {
    "prefix": "mapinsmn",
    "body": ["m.insert({$1, $2});"],
    "description": "Map Insert Manual C++"
  },
  "Map Insert MP C++": {
    "prefix": "mapinsmp",
    "body": ["m.insert(make_pair($1, $2));"],
    "description": "Map Insert MP C++"
  },
  "Map Insert Pair MN C++": {
    "prefix": "mapinspmn",
    "body": ["m.insert(pair<int, int>($1, $2));"],
    "description": "Map Insert Pair MN C++"
  },
  "Map Create GT C++": {
    "prefix": "mapcrgt",
    "body": ["map<int, int, greater<int>> $1;"],
    "description": "Map Create GT C++"
  },
  "Dijsktra": {
    "prefix": "dijkstra",
    "body": [
      "struct graph {",
      "  long vertexCount, edgeCount;",
      "  vector<vector<pair<long, long>>> adjList;",
      "",
      "  void init(long v) {",
      "    vertexCount = v;",
      "    edgeCount = 0;",
      "",
      "    for (int i = 0; i < vertexCount; i++) {",
      "      adjList.push_back({}); // inserts V ammount of empty vector",
      "    }",
      "  }",
      "",
      "  void add_edge(long vertex1, long vertex2, long weight) {",
      "    adjList[vertex1].push_back(make_pair(vertex2, weight));",
      "    adjList[vertex2].push_back(make_pair(vertex1, weight));",
      "    edgeCount++;",
      "  }",
      "  ",
      "  void dijkstra(vector<long> &result, vector<long> &prev, long start) {",
      "    vector<bool> visited(vertexCount, false);",
      "    priority_queue<pair<long, long>, vector<pair<long, long>>,",
      "                   greater<pair<long, long>>>",
      "        pq;",
      "    result = vector<long>(vertexCount, LONG_MAX);",
      "    prev = vector<long>(vertexCount, -1);",
      "",
      "    pq.push(make_pair(0, start));",
      "    result[start] = 0;",
      "",
      "    while (!pq.empty()) {",
      "      auto temp = pq.top();",
      "      pq.pop();",
      "",
      "      visited[temp.second] = true;",
      "",
      "      for (auto vertex : adjList[temp.second]) {",
      "        long nextVertex = vertex.first;",
      "        long weight = vertex.second;",
      "",
      "        if (!visited[nextVertex]) {",
      "          if (temp.first + weight < result[nextVertex]) {",
      "            result[nextVertex] = temp.first + weight;",
      "            prev[nextVertex] = temp.second;",
      "            pq.push(make_pair(result[nextVertex], nextVertex));",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  void printPath(long end, const vector<long> &prev) {",
      "    if (prev[end] == -1) {",
      "      cout << end;",
      "      return;",
      "    }",
      "",
      "    printPath(prev[end], prev);",
      "    cout << \" -> \" << end;",
      "  }",
      "}"
    ],
    "description": "Dijsktra"
  },
  "Kruskal": {
    "prefix": "kruskal",
    "body": [
      "struct graph {",
      "  long vertexCount, edgeCount;",
      "  vector<vector<pair<long, long>>> adjList;",
      "",
      "  void init(long v) {",
      "    vertexCount = v;",
      "    edgeCount = 0;",
      "",
      "    for (int i = 0; i < vertexCount; i++) {",
      "      adjList.push_back({}); // inserts V ammount of empty vector",
      "    }",
      "  }",
      "",
      "  void add_edge(long vertex1, long vertex2, long weight) {",
      "    adjList[vertex1].push_back(make_pair(vertex2, weight));",
      "    adjList[vertex2].push_back(make_pair(vertex1, weight));",
      "    edgeCount++;",
      "  }",
      "",
      "  long find_parent(vector<long> &parent, long v) {",
      "    if (v == parent[v])",
      "      return v;",
      "",
      "    return parent[v] = find_parent(parent, parent[v]);",
      "  }",
      "",
      "  void union_set(vector<long> &parent, long vertex1, long vertex2) {",
      "    int parent1 = find_parent(parent, vertex1);",
      "    int parent2 = find_parent(parent, vertex2);",
      "",
      "    if (parent1 != parent2)",
      "      parent[parent2] = parent1;",
      "  }",
      "",
      "  void kruskal(vector<pair<long, pair<long, long>>> &result) {",
      "    vector<long> parent;",
      "    for (int i = 0; i < vertexCount; i++)",
      "      parent.push_back(i);",
      "",
      "    sort(edgeList.begin(), edgeList.end());",
      "",
      "    for (auto edge : edgeList) {",
      "      long vertex1 = edge.second.first;",
      "      long vertex2 = edge.second.second;",
      "      if (find_parent(parent, vertex1) != find_parent(parent, vertex2)) {",
      "        result.push_back(edge);",
      "        union_set(parent, vertex1, vertex2);",
      "        if (result.size() == vertexCount - 1)",
      "          return;",
      "      }",
      "    }",
      "  }",
      "};",
      ""
    ],
    "description": "Kruskal"
  },
  "BFS": {
    "prefix": "bfs",
    "body": [
      "void bfs(vector<long> &result, long start, long L) {",
      "    vector<bool> visited(vertexCount, false);",
      "    queue<long> q;",
      "",
      "    vector<int> dist(vertexCount, INT_MAX);",
      "",
      "    q.push(start);",
      "    visited[start] = true;",
      "    result.push_back(start);",
      "",
      "    dist[start] = 0;",
      "",
      "    while (!q.empty()) {",
      "      long temp = q.front();",
      "      q.pop();",
      "",
      "      for (auto vertex : adjList[temp]) {",
      "        if (!visited[vertex]) {",
      "          q.push(vertex);",
      "          visited[vertex] = true;",
      "          result.push_back(vertex);",
      "",
      "          dist[vertex] = dist[temp] + 1;",
      "        }",
      "      }",
      "    }",
      "",
      "    bool found = false;",
      "    for (int i = 0; i < vertexCount; i++) {",
      "      if (dist[i] == L) {",
      "",
      "        cout << i << endl;",
      "        found = true;",
      "      }",
      "    }",
      "",
      "    if (found == false)",
      "      cout << \"Not Found\" << endl;",
      "  }"
    ],
    "description": "bfs"
  },
  "DFS": {
    "prefix": "dfs",
    "body": [
      "void dfs(vector<long> &result, long start) {",
      "    vector<bool> visited(vertexCount, false);",
      "    vector<long> parent(vertexCount, -1);",
      "    stack<pair<long, long>> st;",
      "",
      "    st.push({start, -1});",
      "",
      "    while (!st.empty()) {",
      "      auto [v, par] = st.top();",
      "      st.pop();",
      "",
      "      if (!visited[v]) {",
      "        visited[v] = true;",
      "        result.push_back(v);",
      "",
      "        for (auto vertex : adjList[v]) {",
      "          if (!visited[vertex]) {",
      "            parent[vertex] = v;",
      "            st.push({vertex, v});",
      "          } else if (vertex != par) {",
      "            cout << \"VOCALOID CYCLE PROGRAM (VCP) : CYCLE DETECTED \";",
      "",
      "            vector<long> cycle;",
      "            auto temp = v;",
      "",
      "            cycle.push_back(v);",
      "",
      "            while (temp != vertex) {",
      "              temp = parent[temp];",
      "              cycle.push_back(temp);",
      "            }",
      "",
      "            sort(cycle.begin(), cycle.end());",
      "",
      "            for (auto j : cycle) {",
      "              cout << j;",
      "              if (j != cycle.back())",
      "                cout << \" \";",
      "              else",
      "                cout << endl;",
      "            }",
      "",
      "            return;",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    cout << \"VOCALOID CYCLE PROGRAM (VCP) : NO CYCLE DETECTED\" << endl;",
      "    return;",
      "  }"
    ],
    "description": "DFS"
  }
}
