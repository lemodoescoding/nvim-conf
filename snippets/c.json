{
  "BST C++": {
    "prefix": "bst",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "struct BSTNode {",
      "    BSTNode *left, *right;",
      "    int key;",
      "};",
      "",
      "struct BST {",
      "    // Member",
      "    BSTNode *_root;",
      "    unsigned int _size;",
      "",
      "    // Function",
      "    void init() {",
      "        _root = NULL;",
      "        _size = 0u;",
      "    }",
      "",
      "    bool isEmpty() {",
      "        return _root == NULL;",
      "    }",
      "",
      "    bool find(int value) {",
      "        BSTNode *temp = __search(_root, value);",
      "        if (!temp)",
      "            return false;",
      "        ",
      "        if (temp->key == value)",
      "            return true;",
      "        else",
      "            return false;",
      "    }",
      "",
      "    void insert(int value) {",
      "        if (!find(value)) {",
      "            _root = __insert(_root, value);",
      "            _size++;",
      "        }",
      "    }",
      "",
      "    void remove(int value) {",
      "        if (find(value)) {",
      "            _root = __remove(_root, value);",
      "            _size++;",
      "        }",
      "    }",
      "",
      "    void traverseInorder() {",
      "        __inorder(_root);",
      "    }",
      "",
      "    void traversePreorder() {",
      "        __preorder(_root);",
      "    }",
      "",
      "    void traversePostorder() {",
      "        __postorder(_root);",
      "    }",
      "",
      "private:",
      "    // Utility Function",
      "    BSTNode* __createNode(int value) {",
      "        BSTNode *newNode = (BSTNode*) malloc(sizeof(BSTNode));",
      "        newNode->key = value;",
      "        newNode->left = newNode->right = NULL;",
      "        return newNode;",
      "    }",
      "    ",
      "    BSTNode* __search(BSTNode *root, int value) {",
      "        while (root != NULL) {",
      "            if (value < root->key)",
      "                root = root->left;",
      "            else if (value > root->key)",
      "                root = root->right;",
      "            else",
      "                return root;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    BSTNode* __insert(BSTNode *root, int value) {",
      "        if (root == NULL)",
      "            return __createNode(value);",
      "        ",
      "        if (value < root->key)",
      "            root->left = __insert(root->left, value);",
      "        else if (value > root->key)",
      "            root->right = __insert(root->right, value);",
      "        ",
      "        return root;",
      "    }",
      "",
      "    BSTNode* __findMinNode(BSTNode *node) {",
      "        BSTNode *currNode = node;",
      "        while (currNode && currNode->left != NULL)",
      "            currNode = currNode->left;",
      "        ",
      "        return currNode;",
      "    }",
      "",
      "    BSTNode* __remove(BSTNode *root, int value) {",
      "        if (root == NULL) return NULL;",
      "",
      "        if (value > root->key) ",
      "            root->right = __remove(root->right, value);",
      "        else if (value < root->key) ",
      "            root->left = __remove(root->left, value);",
      "        else {",
      "",
      "            if (root->left == NULL) {",
      "                BSTNode *rightChild = root->right;",
      "                free(root);",
      "                return rightChild;",
      "            }",
      "            else if (root->right == NULL) {",
      "                BSTNode *leftChild = root->left;",
      "                free(root);",
      "                return leftChild;",
      "            }",
      "",
      "            BSTNode *temp = __findMinNode(root->right);",
      "            root->key     = temp->key;",
      "            root->right   = __remove(root->right, temp->key);",
      "        }",
      "        return root;",
      "    }",
      "",
      "    void __inorder(BSTNode *root) {",
      "        if (root) {",
      "            __inorder(root->left);",
      "            printf(\"%d \", root->key);",
      "            __inorder(root->right);",
      "        }",
      "    }",
      "",
      "    void __postorder(BSTNode *root) {",
      "        if (root) {",
      "            __postorder(root->left);",
      "            __postorder(root->right);",
      "            printf(\"%d \", root->key);",
      "        }",
      "    }",
      "",
      "    void __preorder(BSTNode *root) {",
      "        if (root) {",
      "            printf(\"%d \", root->key);",
      "            __preorder(root->left);",
      "            __preorder(root->right);",
      "        }",
      "    }",
      "};"
    ],
    "description": "BST Tree Code C/C++"
  },
  "BST C": {
    "prefix": "bst_c",
    "body": [
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "",
      "typedef struct bstnode_t {",
      "    int key;",
      "    struct bstnode_t \\",
      "        *left, *right;",
      "} BSTNode;",
      "",
      "typedef struct bst_t {",
      "    BSTNode *_root;",
      "    unsigned int _size;",
      "} BST;",
      "",
      "BSTNode* __bst__createNode(int value) {",
      "    BSTNode *newNode = (BSTNode*) malloc(sizeof(BSTNode));",
      "    newNode->key = value;",
      "    newNode->left = newNode->right = NULL;",
      "    return newNode;",
      "}",
      "",
      "BSTNode* __bst__insert(BSTNode *root, int value) {",
      "    if (root == NULL) ",
      "        return __bst__createNode(value);",
      "",
      "    if (value < root->key)",
      "        root->left = __bst__insert(root->left, value);",
      "    else if (value > root->key)",
      "        root->right = __bst__insert(root->right, value);",
      "    ",
      "    return root;",
      "}",
      "",
      "BSTNode* __bst__search(BSTNode *root, int value) {",
      "    while (root != NULL) {",
      "        if (value < root->key)",
      "            root = root->left;",
      "        else if (value > root->key)",
      "            root = root->right;",
      "        else",
      "            return root;",
      "    }",
      "    return root;",
      "}",
      "",
      "BSTNode* __bst__findMinNode(BSTNode *node) {",
      "    BSTNode *currNode = node;",
      "    while (currNode && currNode->left != NULL)",
      "        currNode = currNode->left;",
      "    ",
      "    return currNode;",
      "}",
      "",
      "BSTNode* __bst__remove(BSTNode *root, int value) {",
      "    if (root == NULL) return NULL;",
      "",
      "    if (value > root->key) ",
      "        root->right = __bst__remove(root->right, value);",
      "    else if (value < root->key) ",
      "        root->left = __bst__remove(root->left, value);",
      "    else {",
      "        ",
      "        if (root->left == NULL) {",
      "            BSTNode *rightChild = root->right;",
      "            free(root);",
      "            return rightChild;",
      "        }",
      "        else if (root->right == NULL) {",
      "            BSTNode *leftChild = root->left;",
      "            free(root);",
      "            return leftChild;",
      "        }",
      "",
      "        BSTNode *temp = __bst__findMinNode(root->right);",
      "        root->key     = temp->key;",
      "        root->right   = __bst__remove(root->right, temp->key);",
      "    }",
      "    return root;",
      "}",
      "",
      "void __bst__inorder(BSTNode *root) {",
      "    if (root) {",
      "        __bst__inorder(root->left);",
      "        printf(\"%d \", root->key);",
      "        __bst__inorder(root->right);",
      "    }",
      "}",
      "",
      "void __bst__postorder(BSTNode *root) {",
      "    if (root) {",
      "        __bst__postorder(root->left);",
      "        __bst__postorder(root->right);",
      "        printf(\"%d \", root->key);",
      "    }",
      "}",
      "",
      "void __bst__preorder(BSTNode *root) {",
      "    if (root) {",
      "        printf(\"%d \", root->key);",
      "        __bst__preorder(root->left);",
      "        __bst__preorder(root->right);",
      "    }",
      "}",
      "",
      "void bst_init(BST *bst) {",
      "    bst->_root = NULL;",
      "    bst->_size = 0u;",
      "}",
      "",
      "bool bst_isEmpty(BST *bst) {",
      "    return bst->_root == NULL;",
      "}",
      "",
      "bool bst_find(BST *bst, int value) {",
      "    BSTNode *temp = __bst__search(bst->_root, value);",
      "    if (temp == NULL)",
      "        return false;",
      "    ",
      "    if (temp->key == value)",
      "        return true;",
      "    else",
      "        return false;",
      "}",
      "",
      "void bst_insert(BST *bst, int value) {",
      "    if (!bst_find(bst, value)) {",
      "        bst->_root = __bst__insert(bst->_root, value);",
      "        bst->_size++;",
      "    }",
      "}",
      "",
      "void bst_remove(BST *bst, int value) {",
      "    if (bst_find(bst, value)) {",
      "        bst->_root = __bst__remove(bst->_root, value);",
      "        bst->_size--;",
      "    }",
      "}"
    ],
    "description": "BST C"
  },
  "AVL Tree Init": {
    "prefix": "avl_init",
    "body": [
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "typedef struct Node {",
      "  int _data, _height;",
      "  struct Node *_left, *_right;",
      "} AVLNode;",
      "",
      "typedef struct {",
      "  AVLNode *_root;",
      "  size_t _size;",
      "} AVLTree;"
    ],
    "description": "AVL Tree Init"
  },
  "AVL Tree Utils": {
    "prefix": "avl_utils",
    "body": [
      "int _getHeight(AVLNode *node) { return (node == NULL) ? 0 : node->_height; }",
      "",
      "int _getBalanceFactor(AVLNode *node) {",
      "  if (node == NULL)",
      "    return 0;",
      "",
      "  return _getHeight(node->_left) - _getHeight(node->_right);",
      "}",
      "",
      "int _max(int a, int b) { return (a > b) ? a : b; }"
    ],
    "description": "AVL Tree Utils"
  },
  "AVL Node Create": {
    "prefix": "avl_creat",
    "body": [
      "AVLNode *createNode(int data) {",
      "  AVLNode *temp = (AVLNode *)malloc(sizeof(AVLNode));",
      "",
      "  if (!temp)",
      "    return NULL;",
      "",
      "  temp->_data = data;",
      "  temp->_height = 1;",
      "  temp->_left = temp->_right = NULL;",
      "",
      "  return temp;",
      "}"
    ],
    "description": "AVL Node Create"
  },
  "AVL Rotate": {
    "prefix": "avl_rotat",
    "body": [
      "AVLNode *avlRightRotate(AVLNode *pivotNode) {",
      "  AVLNode *newParent = pivotNode->_left;",
      "  pivotNode->_left = newParent->_right;",
      "  newParent->_right = pivotNode;",
      "",
      "  pivotNode->_height =",
      "      _max(_getHeight(pivotNode->_left), _getHeight(pivotNode->_right)) + 1;",
      "  newParent->_height =",
      "      _max(_getHeight(newParent->_left), _getHeight(newParent->_right)) + 1;",
      "",
      "  return newParent;",
      "}",
      "",
      "AVLNode *avlLeftRotate(AVLNode *pivotNode) {",
      "  AVLNode *newParent = pivotNode->_right;",
      "  pivotNode->_right = newParent->_left;",
      "  newParent->_left = pivotNode;",
      "",
      "  pivotNode->_height =",
      "      _max(_getHeight(pivotNode->_left), _getHeight(pivotNode->_right)) + 1;",
      "  newParent->_height =",
      "      _max(_getHeight(newParent->_left), _getHeight(newParent->_right)) + 1;",
      "",
      "  return newParent;",
      "}",
      "",
      "AVLNode *leftCaseRotate(AVLNode *node) { return avlRightRotate(node); }",
      "AVLNode *rightCaseRotate(AVLNode *node) { return avlLeftRotate(node); }",
      "",
      "AVLNode *leftRightCaseRotate(AVLNode *node) {",
      "  node->_left = avlLeftRotate(node->_left);",
      "  return avlRightRotate(node);",
      "}",
      "",
      "AVLNode *rightLeftCaseRotate(AVLNode *node) {",
      "  node->_right = avlRightRotate(node->_right);",
      "  return avlLeftRotate(node);",
      "}"
    ],
    "description": "AVL Rotate"
  },
  "AVL Find": {
    "prefix": "avl_find",
    "body": [
      "AVLNode *avlSearchNode(AVLNode *root, int data) {",
      "  if (root == NULL)",
      "    return root;",
      "",
      "  if (data < root->_data) {",
      "    return avlSearchNode(root->_left, data);",
      "  } else if (data > root->_data) {",
      "    return avlSearchNode(root->_right, data);",
      "  } else {",
      "    return root;",
      "  }",
      "}",
      "",
      "bool AVLFindNode(AVLTree *avl, int data) {",
      "  AVLNode *temp = avlSearchNode(avl->_root, data);",
      "",
      "  if (temp == NULL || temp->_data != data)",
      "    return false;",
      "  else",
      "    return true;",
      "}"
    ],
    "description": "AVL Find"
  },
  "AVL Insert": {
    "prefix": "avl_insert",
    "body": [
      "AVLNode *avlInsertNode(AVLTree *avl, AVLNode *node, int data) {",
      "  if (node == NULL)",
      "    return createNode(data);",
      "",
      "  if (data < node->_data)",
      "    node->_left = avlInsertNode(avl, node->_left, data);",
      "  else if (data > node->_data)",
      "    node->_right = avlInsertNode(avl, node->_right, data);",
      "",
      "  node->_height = 1 + _max(_getHeight(node->_left), _getHeight(node->_right));",
      "",
      "  int balanceFactor = _getBalanceFactor(node);",
      "  if (balanceFactor > 1 && data < node->_left->_data)",
      "    return leftCaseRotate(node);",
      "  if (balanceFactor > 1 && data > node->_left->_data)",
      "    return leftRightCaseRotate(node);",
      "  if (balanceFactor < -1 && data > node->_right->_data)",
      "    return rightCaseRotate(node);",
      "  if (balanceFactor < -1 && data < node->_right->_data)",
      "    return rightLeftCaseRotate(node);",
      "",
      "  return node;",
      "}",
      "",
      "void InsertToAVL(AVLTree *avl, int data) {",
      "  if (AVLFindNode(avl, data))",
      "    return;",
      "",
      "  avl->_root = avlInsertNode(avl, avl->_root, data);",
      "  avl->_size++;",
      "}"
    ],
    "description": "AVL Insert"
  },
  "AVL Delete": {
    "prefix": "avl_del",
    "body": [
      "AVLNode *_findMinNode(AVLNode *node) {",
      "  AVLNode *currNode = node;",
      "  while (currNode && currNode->_left != NULL)",
      "    currNode = currNode->_left;",
      "  return currNode;",
      "}",
      "",
      "AVLNode *_remove_AVL(AVLNode *node, int value) {",
      "  if (node == NULL)",
      "    return node;",
      "  if (value > node->_data)",
      "    node->_right = _remove_AVL(node->_right, value);",
      "  else if (value < node->_data)",
      "    node->_left = _remove_AVL(node->_left, value);",
      "  else {",
      "    AVLNode *temp;",
      "    if ((node->_left == NULL) || (node->_right == NULL)) {",
      "      temp = NULL;",
      "      if (node->_left == NULL)",
      "        temp = node->_right;",
      "      else if (node->_right == NULL)",
      "        temp = node->_left;",
      "",
      "      if (temp == NULL) {",
      "        temp = node;",
      "        node = NULL;",
      "      } else",
      "        *node = *temp;",
      "",
      "      free(temp);",
      "    } else {",
      "      temp = _findMinNode(node->_right);",
      "      node->_data = temp->_data;",
      "      node->_right = _remove_AVL(node->_right, temp->_data);",
      "    }",
      "  }",
      "  if (node == NULL)",
      "    return node;",
      "",
      "  node->_height = _max(_getHeight(node->_left), _getHeight(node->_right)) + 1;",
      "",
      "  int balanceFactor = _getBalanceFactor(node);",
      "",
      "  if (balanceFactor > 1 && _getBalanceFactor(node->_left) >= 0)",
      "    return leftCaseRotate(node);",
      "",
      "  if (balanceFactor > 1 && _getBalanceFactor(node->_left) < 0)",
      "    return leftRightCaseRotate(node);",
      "",
      "  if (balanceFactor < -1 && _getBalanceFactor(node->_right) <= 0)",
      "    return rightCaseRotate(node);",
      "",
      "  if (balanceFactor < -1 && _getBalanceFactor(node->_right) > 0)",
      "    return rightLeftCaseRotate(node);",
      "",
      "  return node;",
      "}"
    ],
    "description": "AVL Delete"
  },
  "Simple printf": {
    "prefix": "ptf",
    "body": ["printf(\"$1\", $2);"],
    "description": "Simple printf"
  },
  "Simple printf C++": {
    "prefix": "ptf_cpp",
    "body": ["cout << \"$1\" << endl;"],
    "description": "Simple printf C++"
  },
  "Set Int C++": {
    "prefix": "seti",
    "body": ["#include <set>", "", "set<int> ${1:mySet};"],
    "description": "Set Int C++"
  },
  "Set GtInt C++": {
    "prefix": "setgti",
    "body": ["set<int, greater<int>> $1;"],
    "description": "Set GtInt C++"
  },
  "Loop Set C++": {
    "prefix": "stdlp",
    "body": [
      " for (auto i = $1.begin(); i != $1.end(); i++) {",
      "   cout << *i << endl;",
      " }"
    ],
    "description": "Loop Set C++"
  },
  "Std Find C++": {
    "prefix": "stdfd",
    "body": ["auto pointer = $1.find($2);"],
    "description": "Set Find C++"
  },
  "Std Del C++": {
    "prefix": "stddl",
    "body": ["$1.erase($2);"],
    "description": "Set Del C++"
  },
  "Map Creat C++": {
    "prefix": "mapcr",
    "body": ["map<int, int> $1;"],
    "description": "Map Creat C++"
  },
  "Map Insert Manual C++": {
    "prefix": "mapinsmn",
    "body": ["m.insert({$1, $2});"],
    "description": "Map Insert Manual C++"
  },
  "Map Insert MP C++": {
    "prefix": "mapinsmp",
    "body": ["m.insert(make_pair($1, $2));"],
    "description": "Map Insert MP C++"
  },
  "Map Insert Pair MN C++": {
    "prefix": "mapinspmn",
    "body": ["m.insert(pair<int, int>($1, $2));"],
    "description": "Map Insert Pair MN C++"
  },
  "Map Create GT C++": {
    "prefix": "mapcrgt",
    "body": ["map<int, int, greater<int>> $1;"],
    "description": "Map Create GT C++"
  }
}
